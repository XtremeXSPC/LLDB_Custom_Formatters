<!DOCTYPE html>
<html>
  <head>
    <title>Interactive List Visualizer</title>
    <style>
      /* Injected styles start */
      __SHARED_CSS__
      /* Injected styles end */
  
      /* Fallback/base styles to maintain syntax highlighting */
      body {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <!-- UI Controls -->
    <button
      id="toggle-info-btn"
      onclick="toggleInfoBox()"
      title="Toggle Info Panel"
    >
      ⚙️
    </button>

    <div id="info-box" class="hidden">
      <h3>List Controls</h3>

      <div class="theme-controls">
        <button id="theme-toggle-btn" onclick="toggleTheme()">
          Switch to Light Theme
        </button>
      </div>

      <!-- View Operations -->
      <div class="controls-section">
        <div class="section-title">View Operations</div>
        <div class="button-group">
          <button id="btn-center" class="button" onclick="centerView()">
            Center
          </button>
          <button id="btn-clear" class="button" onclick="clearSelection()">
            Clear
          </button>
        </div>
      </div>

      <!-- Layout Controls -->
      <div class="controls-section layout-controls">
        <div class="section-title">Layout</div>
        <div class="button-group">
          <button
            class="button active"
            onclick="setLayout('hierarchical')"
            id="hierarchical-btn"
          >
            Horizontal
          </button>
          <button
            class="button"
            onclick="setLayout('vertical')"
            id="vertical-btn"
          >
            Vertical
          </button>
          <button class="button" onclick="setLayout('radial')" id="radial-btn">
            Radial
          </button>
        </div>
      </div>

      <!-- Animation Controls -->
      <div class="controls-section animation-controls">
        <div class="section-title">Animation</div>
        <button
          id="btn-play"
          class="button play-button"
          onclick="playAnimation()"
        >
          Play Traversal
        </button>
        <div class="speed-control">
          <span>Speed:</span>
          <input
            type="range"
            id="speed-slider"
            min="100"
            max="1000"
            value="400"
            step="50"
            oninput="updateSpeed(this.value)"
          />
          <span id="speed-value">400ms</span>
        </div>
        <div class="button-group">
          <button id="btn-pause" class="button" onclick="pauseAnimation()">
            Pause
          </button>
          <button id="btn-stop" class="button" onclick="stopAnimation()">
            Stop
          </button>
          <button id="btn-step" class="button" onclick="stepAnimation()">
            Step
          </button>
        </div>
      </div>

      <!-- Search Controls -->
      <div class="controls-section search-controls">
        <div class="section-title">Search & Highlight</div>
        <input
          type="text"
          class="search-box"
          id="search-input"
          placeholder="Search node values..."
          oninput="searchNodes(this.value)"
        />
        <div class="button-group" style="margin-top: 8px">
          <button class="button" onclick="clearHighlights()">
            Clear Search
          </button>
        </div>
      </div>

      <!-- Statistics and Node Info -->
      <div class="stats-display" id="stats-display">
        <div class="section-title">List Statistics</div>
        <div id="list-stats"></div>
      </div>

      <div class="node-info" id="node-info" style="display: none">
        <div class="section-title">Selected Node</div>
        <div id="node-details"></div>
      </div>

      <!-- Legend -->
      <div class="legend">
        <div class="section-title">Legend</div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #7aa2f7"></div>
          <span>Normal</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #9ece6a"></div>
          <span>Current/Animated</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #e0af68"></div>
          <span>Highlighted</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background-color: #f7768e"></div>
          <span>Search Result</span>
        </div>
      </div>

      <!-- Export Controls -->
      <div class="controls-section export-controls">
        <div class="section-title">Export</div>
        <div class="button-group">
          <button id="btn-png" class="button" onclick="exportPNG()">PNG</button>
          <button id="btn-json" class="button" onclick="customExportJSON()">
            JSON
          </button>
        </div>
      </div>
    </div>

    <!-- Vis.js Container -->
    <div id="mynetwork"></div>

    <!-- Scripts -->
    <script type="text/javascript">
      // Include the vis.js library
      __VISJS_LIBRARY__;
    </script>
    <script type="text/javascript">
      // Common JS functions will be injected here by Python
      __SHARED_JS__;
    </script>
    <script type="text/javascript">
      // ----- Data from Python ----- //
      const rawNodesData = __NODES_DATA__;
      const rawEdgesData = __EDGES_DATA__;
      const traversalOrder = __TRAVERSAL_ORDER_DATA__;
      const isDoublyLinked = __IS_DOUBLY_LINKED__;

      // ----- Vis.js & Animation State Setup ----- //
      let network;
      let currentLayout = "hierarchical";
      let animationState = {
        isPlaying: false,
        isPaused: false,
        currentStep: 0,
        timeouts: [],
        speed: 400,
      };

      // Process raw data
      const processedNodes = rawNodesData.map((node) => ({
        id: node.id,
        label: String(node.value || node.label),
        address: `${node.address || node.id}`,
      }));
      const processedEdges = rawEdgesData.map((edge) => ({
        ...edge,
        arrows: { to: { enabled: true }, from: { enabled: isDoublyLinked } },
      }));

      const nodes = new vis.DataSet(processedNodes);
      const edges = new vis.DataSet(processedEdges);
      const data = { nodes, edges };
      const container = document.getElementById("mynetwork");

      // ----- Layout & Base Options ----- //
      const layoutConfigs = {
        hierarchical: {
          layout: {
            hierarchical: {
              enabled: true,
              direction: "LR",
              sortMethod: "directed",
              nodeSpacing: 100,
              levelSeparation: 150,
            },
          },
          physics: { enabled: false },
        },
        vertical: {
          layout: {
            hierarchical: {
              enabled: true,
              direction: "UD",
              sortMethod: "directed",
              nodeSpacing: 100,
              levelSeparation: 120,
            },
          },
          physics: { enabled: false },
        },
        radial: {
          layout: { randomSeed: 2 },
          physics: {
            enabled: true,
            barnesHut: {
              gravitationalConstant: -5000,
              centralGravity: 0.25,
              springLength: 120,
            },
          },
        },
      };

      const baseOptions = {
        interaction: {
          hover: true,
          tooltipDelay: 200,
          selectConnectedEdges: false,
        },
        nodes: {
          shape: "box",
          shapeProperties: { borderRadius: 6 },
          margin: 12,
          font: {
            color: colorPalette.textDefault,
            size: 16,
            face: "arial",
            bold: { color: colorPalette.textDefault },
          },
          borderWidth: 2,
          color: {
            border: colorPalette.nodeBorder,
            background: colorPalette.nodeDefault,
            highlight: {
              border: colorPalette.nodeSelectedBorder,
              background: colorPalette.nodeSelected,
            },
            hover: {
              border: colorPalette.nodeHover,
              background: colorPalette.nodeHover,
            },
          },
          shadow: {
            enabled: true,
            color: "rgba(0, 0, 0, 0.3)",
            size: 10,
            x: 4,
            y: 4,
          },
        },
        edges: {
          width: 2,
          color: {
            color: colorPalette.edgeDefault,
            highlight: colorPalette.edgeSelected,
            inherit: false,
          },
          smooth: {
            type: "cubicBezier",
            forceDirection: "horizontal",
            roundness: 0.4,
          },
        },
      };

      // ----- List-Specific & Animation Functions ----- //

      /**
       * Creates or recreates the network with a specified layout.
       * @param {string} layoutType - The key for the layout configuration.
       */
      function createNetwork(layoutType) {
        const options = { ...baseOptions, ...layoutConfigs[layoutType] };
        if (network) network.destroy();
        network = new vis.Network(container, data, options);

        // Attach event listeners
        network.on("click", handleNodeClick);
        network.on("hoverNode", handleNodeHover);
        network.on("blurNode", handleNodeBlur);
        network.on("stabilizationIterationsDone", updateStats);
        updateStats(); // Initial call
      }

      /**
       * Changes the network layout and recreates the visualization.
       * @param {string} layoutType - The new layout to apply.
       */
      function setLayout(layoutType) {
        currentLayout = layoutType;
        document
          .querySelectorAll(".layout-controls button")
          .forEach((btn) => btn.classList.remove("active"));
        document.getElementById(`${layoutType}-btn`).classList.add("active");
        createNetwork(layoutType);
      }

      /**
       * Updates the animation speed from the slider.
       */
      function updateSpeed(value) {
        animationState.speed = parseInt(value, 10);
        document.getElementById(
          "speed-value"
        ).textContent = `${animationState.speed}ms`;
      }

      /**
       * Starts or resumes the traversal animation.
       */
      function playAnimation() {
        if (!traversalOrder || traversalOrder.length === 0) {
          console.warn("No traversal order available for animation");
          return;
        }

        if (animationState.isPlaying) return;

        if (animationState.isPaused) {
          resumeAnimation();
          return;
        }

        stopAnimation(); // Reset before starting
        animationState.isPlaying = true;
        const playBtn = document.getElementById("btn-play");
        if (playBtn) {
          playBtn.innerHTML = `<span class="button-icon">${svgIcons.pause}</span> Pause`;
        }

        const animateStep = (index) => {
          if (!animationState.isPlaying || index >= traversalOrder.length) {
            if (index >= traversalOrder.length) stopAnimation();
            return;
          }

          const nodeId = traversalOrder[index];
          nodes.update({
            id: nodeId,
            color: {
              background: colorPalette.nodeAnimated,
              border: colorPalette.nodeAnimatedBorder,
            },
          });

          if (index > 0) {
            const prevNodeId = traversalOrder[index - 1];
            nodes.update({
              id: prevNodeId,
              color: {
                background: colorPalette.nodeDefault,
                border: colorPalette.nodeBorder,
              },
            });
          }

          animationState.currentStep = index;
          const timeoutId = setTimeout(
            () => animateStep(index + 1),
            animationState.speed
          );
          animationState.timeouts.push(timeoutId);
        };

        animateStep(0);
      }

      /**
       * Pauses the current animation.
       */
      function pauseAnimation() {
        if (!animationState.isPlaying) return;

        animationState.isPaused = true;
        animationState.isPlaying = false;
        animationState.timeouts.forEach(clearTimeout);
        animationState.timeouts = [];

        const playBtn = document.getElementById("btn-play");
        if (playBtn) {
          playBtn.innerHTML = `<span class="button-icon">${svgIcons.play}</span> Resume`;
        }
      }

      /**
       * Resumes the paused animation.
       */
      function resumeAnimation() {
        if (!traversalOrder || traversalOrder.length === 0) return;

        animationState.isPaused = false;
        animationState.isPlaying = true;

        const playBtn = document.getElementById("btn-play");
        if (playBtn) {
          playBtn.innerHTML = `<span class="button-icon">${svgIcons.pause}</span> Pause`;
        }

        playAnimationFromStep(animationState.currentStep + 1);
      }

      /**
       * Continues animation from a specific step.
       * @param {number} startIndex - The step index to start from.
       */
      function playAnimationFromStep(startIndex) {
        const animateStep = (index) => {
          if (!animationState.isPlaying || index >= traversalOrder.length) {
            if (index >= traversalOrder.length) stopAnimation();
            return;
          }

          const nodeId = traversalOrder[index];
          nodes.update({
            id: nodeId,
            color: {
              background: colorPalette.nodeAnimated,
              border: colorPalette.nodeAnimatedBorder,
            },
          });

          if (index > 0) {
            const prevNodeId = traversalOrder[index - 1];
            nodes.update({
              id: prevNodeId,
              color: {
                background: colorPalette.nodeDefault,
                border: colorPalette.nodeBorder,
              },
            });
          }

          animationState.currentStep = index;
          const timeoutId = setTimeout(
            () => animateStep(index + 1),
            animationState.speed
          );
          animationState.timeouts.push(timeoutId);
        };

        animateStep(startIndex);
      }

      /**
       * Stops the animation and resets all states.
       */
      function stopAnimation() {
        animationState.isPlaying = false;
        animationState.isPaused = false;
        animationState.timeouts.forEach(clearTimeout);
        animationState.timeouts = [];
        animationState.currentStep = 0;
        resetColors();

        const playBtn = document.getElementById("btn-play");
        if (playBtn) {
          playBtn.innerHTML = `<span class="button-icon">${svgIcons.play}</span> Play Traversal`;
        }
      }

      /**
       * Steps through the animation one node at a time.
       */
      function stepAnimation() {
        if (!traversalOrder || traversalOrder.length === 0) return;
        if (animationState.isPlaying || animationState.isPaused) return;

        resetColors(); // Clear previous steps
        if (animationState.currentStep >= traversalOrder.length) {
          animationState.currentStep = 0; // Loop back
        }

        const nodeId = traversalOrder[animationState.currentStep];
        nodes.update({
          id: nodeId,
          color: {
            background: colorPalette.nodeAnimated,
            border: colorPalette.nodeAnimatedBorder,
          },
        });
        animationState.currentStep++;
      }

      /**
       * Handles node clicks to show information.
       */
      function handleNodeClick(params) {
        if (params.nodes.length > 0) {
          const nodeId = params.nodes[0];
          network.setSelection({ nodes: [nodeId] });
          showNodeInfo(nodes.get(nodeId));
        } else {
          hideNodeInfo();
        }
      }

      /**
       * Displays information for the selected list node.
       */
      function showNodeInfo(nodeData) {
        const infoDiv = document.getElementById("node-info");
        const detailsDiv = document.getElementById("node-details");
        detailsDiv.innerHTML = `<strong>Value:</strong> ${nodeData.label}<br><strong>ID:</strong> ${nodeData.id}<br><strong>Address:</strong> ${nodeData.address}`;
        infoDiv.style.display = "block";
      }

      /**
       * Updates the statistics panel for the list.
       */
      function updateStats() {
        const statsDiv = document.getElementById("list-stats");
        const nodeCount = nodes.length;
        const listType = isDoublyLinked ? "Doubly Linked" : "Singly Linked";
        statsDiv.innerHTML = `<strong>Nodes:</strong> ${nodeCount}<br><strong>Type:</strong> ${listType}<br><strong>Layout:</strong> ${currentLayout}`;
      }

      /**
       * Prepares list data and calls the shared JSON export function.
       */
      function customExportJSON() {
        const listData = {
          nodes: nodes.get(),
          edges: edges.get(),
          traversalOrder: traversalOrder,
          isDoublyLinked: isDoublyLinked,
          layout: currentLayout,
          timestamp: new Date().toISOString(),
        };
        exportJSON(listData, "list-data.json");
      }

      // ----- Initialisation ----- //
      createNetwork(currentLayout);
    </script>
  </body>
</html>
